{"version":3,"sources":["../src/big-counter-x.js"],"names":[],"mappings":"AAAA,OAAO,gBAAP,MAA6B,4BAA7B;AACA,OAAO,KAAP,MAAkB,eAAlB;AACA,OAAO,WAAP,MAAwB,sBAAxB;AAEA;;AACA,IAAM,WAAW,GAAG,KAAK,WAAzB;;AAEA,IAAM,OAAO,GAAG,SAAS,QAAT,CAAkB,GAAlB,EAAuB,KAAvB,EAA8B;AAC5C,SAAO,GAAG,GAAG,KAAb;AACD,CAFD;AAIA;;;;;;;;;AAOA,IAAM,eAAe,GAAG,SAAS,QAAT,GAAoB;AAC1C,SAAO,WAAW,CAAC,KAAK,KAAN,EAAa,OAAb,EAAsB,EAAtB,CAAlB;AACD,CAFD;AAIA;;;;;;;;;;;;;;;;;;AAgBA,IAAM,UAAU,GAAG,SAAS,UAAT,GAAsB;AACvC,MAAI,WAAW,CAAC,IAAD,CAAX,KAAsB,KAAtB,IAA+B,gBAAgB,UAAhB,KAA+B,KAAlE,EAAyE;AACvE,UAAM,IAAI,SAAJ,CAAc,uCAAd,CAAN;AACD;;AAED,EAAA,gBAAgB,CAAC,IAAD,EAAO;AACrB,IAAA,KAAK,EAAE;AACL,MAAA,KAAK,EAAE,CAAC,CAAD;AADF;AADc,GAAP,CAAhB;AAKD,CAVD;;AAYA,gBAAgB,CAAC,UAAU,CAAC,SAAZ,EAAuB;AACrC;;;;;;AAMA,EAAA,GAAG,EAAE;AACH,IAAA,KAAK,EAAE;AADJ,GAPgC;;AAUrC;;;;;;AAMA,EAAA,IAAI,EAAE;AACJ,IAAA,KAAK,EAAE,SAAS,IAAT,GAAgB;AACrB,UAAM,KAAK,GAAG,KAAK,CAAC,KAAK,KAAN,CAAnB;AACA,WAAK,KAAL,CAAW,MAAX,GAAoB,CAApB;AAFqB,UAGd,MAHc,GAGJ,KAHI,CAGd,MAHc;AAIrB,UAAM,OAAO,GAAG,MAAM,GAAG,CAAT,GAAa,MAAb,GAAsB,CAAtC;AACA,UAAI,KAAK,GAAG,CAAZ;AACA,UAAI,KAAK,GAAG,CAAZ;;AACA,aAAO,KAAK,GAAG,OAAR,IAAmB,KAA1B,EAAiC;AAC/B,YAAM,EAAE,GAAG,KAAK,IAAI,KAAK,CAAC,KAAD,CAAL,IAAgB,CAApB,CAAL,IAA+B,KAAK,KAAK,CAAzC,CAAX;AACA,aAAK,KAAL,CAAW,KAAK,KAAL,CAAW,MAAtB,IAAgC,EAAE,GAAG,EAArC;AACA;;AACA,QAAA,KAAK,GAAI,EAAE,GAAG,EAAN,IAAa,CAArB,CAJ+B,CAIP;;AACxB,QAAA,KAAK,IAAI,CAAT;AACD;;AAED,aAAO,IAAP;AACD;AAjBG,GAhB+B;;AAmCrC;;;;;;AAMA,EAAA,KAAK,EAAE;AACL,IAAA,KAAK,EAAE,SAAS,KAAT,GAAiB;AACtB,WAAK,KAAL,CAAW,MAAX,GAAoB,CAApB;AACA,WAAK,KAAL,CAAW,CAAX,IAAgB,CAAhB;AAEA,aAAO,IAAP;AACD;AANI,GAzC8B;;AAiDrC;;;;;;AAMA,EAAA,MAAM,EAAE;AACN,IAAA,KAAK,EAAE;AADD,GAvD6B;;AA0DrC;;;;;;AAMA,EAAA,QAAQ,EAAE;AACR,IAAA,KAAK,EAAE;AADC,GAhE2B;;AAmErC;;;;;;AAMA,EAAA,OAAO,EAAE;AACP,IAAA,KAAK,EAAE;AADA;AAzE4B,CAAvB,CAAhB;AA8EA,eAAe,UAAf","file":"big-counter-x.esm.js","sourcesContent":["import defineProperties from 'object-define-properties-x';\nimport slice from 'array-slice-x';\nimport reduceRight from 'array-reduce-right-x';\n\n/** @type {BooleanConstructor} */\nconst castBoolean = true.constructor;\n\nconst reducer = function _reducer(acc, digit) {\n  return acc + digit;\n};\n\n/**\n * Serialise the counter´s current value.\n *\n * @private\n * @this BigCounter\n * @returns {string} A string representation of an integer.\n */\nconst counterToString = function ToString() {\n  return reduceRight(this.count, reducer, '');\n};\n\n/**\n * Incremental integer counter. Counts from `0` to very big integers.\n * Javascript´s number type allows you to count in integer steps\n * from `0` to `9007199254740991`. As of ES5, Strings can contain\n * approximately 65000 characters and ES6 is supposed to handle\n * the `MAX_SAFE_INTEGER` (though I don´t believe any environments supports\n * this). This counter represents integer values as strings and can therefore\n * count in integer steps from `0` to the maximum string length (that´s some\n * 65000 digits). In the lower range, upto `9007199254740991`, the strings can\n * be converted to safe Javascript integers `Number(value)` or `+value`. This\n * counter is great for any applications that need a really big count\n * represented as a string, (an ID string).\n *\n * @class\n * @property {Array<number>} count - A representation of a big number.\n */\nconst BigCounter = function BigCounter() {\n  if (castBoolean(this) === false || this instanceof BigCounter === false) {\n    throw new TypeError('Constructor BigCounter requires \"new\"');\n  }\n\n  defineProperties(this, {\n    count: {\n      value: [0],\n    },\n  });\n};\n\ndefineProperties(BigCounter.prototype, {\n  /**\n   * Gets the counter´s current value.\n   *\n   * @function\n   * @returns {string} A string representation of an integer.\n   */\n  get: {\n    value: counterToString,\n  },\n  /**\n   * Increments the counter´s value by `1`.\n   *\n   * @function\n   * @returns {object} The counter object.\n   */\n  next: {\n    value: function next() {\n      const clone = slice(this.count);\n      this.count.length = 0;\n      const {length} = clone;\n      const howMany = length > 0 ? length : 1;\n      let carry = 0;\n      let index = 0;\n      while (index < howMany || carry) {\n        const zi = carry + (clone[index] || 0) + (index === 0);\n        this.count[this.count.length] = zi % 10;\n        /* eslint-disable-next-line no-bitwise */\n        carry = (zi / 10) >> 0; // floor\n        index += 1;\n      }\n\n      return this;\n    },\n  },\n  /**\n   * Resets the counter back to `0`.\n   *\n   * @function\n   * @returns {object} The counter object.\n   */\n  reset: {\n    value: function reset() {\n      this.count.length = 1;\n      this.count[0] = 0;\n\n      return this;\n    },\n  },\n  /**\n   * Gets the counter´s current value.\n   *\n   * @function\n   * @returns {string} A string representation of an integer.\n   */\n  toJSON: {\n    value: counterToString,\n  },\n  /**\n   * Gets the counter´s current value.\n   *\n   * @function\n   * @returns {string} A string representation of an integer.\n   */\n  toString: {\n    value: counterToString,\n  },\n  /**\n   * Gets the counter´s current value.\n   *\n   * @function\n   * @returns {string} A string representation of an integer.\n   */\n  valueOf: {\n    value: counterToString,\n  },\n});\n\nexport default BigCounter;\n"]}